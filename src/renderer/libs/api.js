// redis数据类型对象, 例如string类型的r_type为1const rTypeDict = {string: 1, hash: 2, list: 3, set: 4, zset: 5};// action操作类型说明// 1-刷新，2-设置过期时间，3-重命名，4-复制，5-删除，6-值变更// type操作类型说明// 1-name操作，2-key_field操作function compare(property) {    // 对数组中的对象排序    return function (current, next) {        let curVal = current[property];        let nexVal = next[property];        return curVal > nexVal ? 1 : -1;    }}function RedisPing(conn) {    return new Promise(async (resolve, reject) => {        let resp = await new Promise(inResolve => {            conn.ping(function (err, res) {                inResolve({result: res, error: err})            })        });        if (resp.error) {            reject(resp.error.toString())        } else {            resolve()        }    })}function RedisType(conn, name) {    return new Promise(async (resolve, reject) => {        let resp = await new Promise(inResolve => {            conn.type(name, function (err, res) {                inResolve({result: res, error: err})            });        });        if (resp.error) {            reject()        } else {            resolve(resp.result)        }    })}function RedisInfo(conn, args) {    // 获取当前库中所有的name数据    return new Promise(async (outResolve, outReject) => {        let retList = [];        let resp = await new Promise(resolve => {            if (args.params) {                conn.keys(`${args.params}*`, function (err, res) {                    res.forEach(async item => {                        let ret = await new Promise(inResole => {                            conn.type(item, function (err, res) {                                let typeStr = res.toString();                                return inResole({                                    type: typeStr === "string" ? "Str" : typeStr.slice(0, 1).toUpperCase() + typeStr.slice(1),                                    name: item,                                    r_type: rTypeDict[typeStr]                                })                            });                        });                        retList.push(ret);                        if (res.length === retList.length) {                            resolve({result: retList, cursor: 0, error: err})                        }                    });                });            } else {                conn.scan(args.cursor, "COUNT", 30, function (scanErr, scanRes) {                    let sRes = scanRes[1];                    let cursor = scanRes[0];                    sRes.forEach(async item => {                        let ret = await new Promise(sResole => {                            conn.type(item, function (err, res) {                                let typeStr = res.toString();                                return sResole({                                    type: typeStr === "string" ? "Str" : typeStr.slice(0, 1).toUpperCase() + typeStr.slice(1),                                    name: item,                                    r_type: rTypeDict[typeStr]                                })                            });                        });                        retList.push(ret);                        if (sRes.length === retList.length) {                            resolve({result: retList, cursor: cursor, error: scanErr})                        }                    });                });            }        });        if (resp.error) {            outReject(resp.error.toString())        } else {            let sortList = resp.result.sort(compare('type'));            outResolve({result: sortList, cursor: resp.cursor})        }    })}function RedisName(conn, args) {    // 添加redis的name    return new Promise(async (resolve, reject) => {        let error = null;        error = await new Promise(inResolve => {            conn.exists(args.name, function (err, res) {                let resError = err ? err : (res ? "目标key已存在" : null);                inResolve(resError)            })        });        if (!error) {            switch (args.r_type) {                case 1:                    error = await new Promise(inResolve => {                        conn.setnx(args.name, "", function (err, _) {                            inResolve(err)                        })                    });                    break;                case 2:                    error = await new Promise(inResolve => {                        conn.hset(args.name, "NewKey", "NewValue", function (err, _) {                            inResolve(err)                        })                    });                    break;                case 3:                    error = await new Promise(inResolve => {                        conn.lpush(args.name, "NewItem", function (err, _) {                            inResolve(err)                        })                    });                    break;                case 4:                    error = await new Promise(inResolve => {                        conn.sadd(args.name, "NewMember", function (err, _) {                            inResolve(err)                        })                    });                    break;                case 5:                    error = await new Promise(inResolve => {                        conn.zadd(args.name, [0, "NewMember"], function (err, _) {                            inResolve(err)                        })                    });                    break;                default:                    error = "错误的操作";                    break;            }        }        if (error) {            reject(error.toString())        } else {            resolve()        }    })}function RedisKey(conn, args) {    // 添加redis的key_field    return new Promise(async (resolve, reject) => {        let error = null;        switch (args.r_type) {            case 1:                error = "错误的操作";                break;            case 2:                error = await new Promise(inResolve => {                    conn.hsetnx(args.name, args.params, "NewValue", function (err, res) {                        let retError = err ? err : (res ? null : "目标key已存在");                        inResolve(retError)                    });                });                break;            case 3:                if (args.params === "0") {                    error = await new Promise(inResolve => {                        conn.lpush(args.name, "NewItem", function (err, _) {                            inResolve(err)                        });                    });                } else {                    error = await new Promise(inResolve => {                        conn.rpush(args.name, "NewItem", function (err, _) {                            inResolve(err)                        });                    });                }                break;            case 4:                error = await new Promise(inResolve => {                    conn.sismember(args.name, args.params, function (err, res) {                        let retError = err ? err : (res ? "目标key已存在" : null);                        inResolve(retError)                    });                });                if (!error) {                    error = await new Promise(inResolve => {                        conn.sadd(args.name, args.params, function (err, _) {                            inResolve(err)                        });                    })                }                break;            case 5:                error = await new Promise(inResolve => {                    conn.zscore(args.name, args.params, function (err, res) {                        let retError = err ? err : (res === null ? null : "目标key已存在");                        inResolve(retError)                    });                });                if (!error) {                    error = await new Promise(inResolve => {                        conn.zadd(args.name, [args.score, args.params], function (err, _) {                            inResolve(err)                        });                    })                }                break;            default:                error = "错误的操作";                break;        }        if (error) {            reject(error)        } else {            resolve()        }    });}function RedisEdit(conn, args) {    // redis数据编辑    return new Promise(async (resolve, reject) => {        let error = null;        switch (args.action) {            case 2:                // 设置过期时间                error = await new Promise(inResolve => {                    conn.expire(args.name, parseInt(args.params), function (err, _) {                        inResolve(err)                    });                });                break;            case 3:                switch (args.type) {                    case 1:                        // name重命名                        error = await new Promise(inResolve => {                            conn.exists(args.params, function (err, res) {                                let retError = err ? err : (res ? "目标key已存在" : null);                                inResolve(retError)                            })                        });                        if (!error) {                            error = await new Promise(inResolve => {                                conn.rename(args.name, args.params, function (err, _) {                                    inResolve(err)                                });                            })                        }                        break;                    case 2:                        if (args.r_type !== 2) {                            error = "错误的操作"                        } else {                            error = await new Promise(inResolve => {                                conn.hexists(args.name, args.params, function (err, res) {                                    let retError = err ? err : (res ? "目标key已存在" : null);                                    inResolve(retError)                                })                            });                            let resp = "";                            if (!error) {                                // 获取值                                resp = await new Promise(inResolve => {                                    conn.hget(args.name, args.key, function (err, res) {                                        let ret = err ? "" : res;                                        inResolve(ret)                                    });                                })                            }                            let setError = null;                            if (resp != null) {                                // 新建值                                setError = await new Promise(inResolve => {                                    conn.hsetnx(args.name, args.params, resp, function (err, _) {                                        inResolve(err)                                    })                                });                            }                            if (!setError) {                                // 删除值                                error = await new Promise(inResolve => {                                    conn.hdel(args.name, args.key, resp, function (err, _) {                                        inResolve(err)                                    })                                });                            } else {                                error = setError                            }                        }                }                break;            case 4:                // 复制                error = await new Promise(inResolve => {                    conn.exists(args.params, function (err, res) {                        let retError = err ? err : (res ? "目标key已存在" : null);                        inResolve(retError)                    })                });                // 获取该类型下所有的key_field及对应值并创建                if (!error) {                    let resp = {result: "", error: null};                    switch (args.r_type) {                        case 1:                            // 字符串类型复制                            resp = await new Promise(iResolve => {                                conn.get(args.name, function (err, res) {                                    iResolve({result: res, error: err})                                })                            });                            if (resp.error) {                                error = resp.error                            } else {                                error = await new Promise(iResolve => {                                    conn.set(args.params, resp.result, function (err, _) {                                        iResolve(err)                                    })                                })                            }                            break;                        case 2:                            // hash类型复制                            resp = await new Promise(iResolve => {                                conn.hgetall(args.name, function (err, res) {                                    iResolve({result: res, error: err})                                })                            });                            if (resp.error) {                                error = resp.error                            } else {                                let fieldList = [];                                let result = resp.result;                                Object.keys(result).forEach(item => {                                    fieldList.push(item, result[item]);                                });                                error = await new Promise(iResolve => {                                    conn.hmset(args.params, fieldList, function (err, _) {                                        iResolve(err)                                    })                                })                            }                            break;                        case 3:                            // list类型复制                            resp = await new Promise(iResolve => {                                conn.llen(args.name, function (err, len) {                                    iResolve({result: len, error: err})                                })                            });                            if (resp.error) {                                error = resp.error                            } else {                                resp = await new Promise(iResolve => {                                    conn.lrange(args.name, 0, resp.result, function (err, res) {                                        iResolve({result: res, error: err})                                    })                                });                                if (resp.error) {                                    error = resp.error                                } else {                                    let itemList = resp.result;                                    error = await new Promise(iResolve => {                                        conn.rpush(args.params, itemList, function (err, _) {                                            iResolve(err)                                        })                                    })                                }                            }                            break;                        case 4:                            // set类型复制                            resp = await new Promise(iResolve => {                                conn.smembers(args.name, function (err, res) {                                    iResolve({result: res, error: err})                                })                            });                            if (resp.error) {                                error = resp.error                            } else {                                error = await new Promise(iResolve => {                                    conn.sadd(args.params, resp.result, function (err, _) {                                        iResolve(err)                                    })                                });                            }                            break;                        case 5:                            // z-set类型复制                            resp = await new Promise(iResolve => {                                conn.zscan(args.name, 0, function (err, res) {                                    iResolve({result: res[1], error: err})                                });                            });                            if (resp.error) {                                error = resp.error                            } else {                                let zSetList = [];                                let nextIndex = 0;                                let resList = resp.result;                                resList.forEach((item, index) => {                                    if (nextIndex <= index) {                                        zSetList.push(resList[index + 1], item);                                        nextIndex += 2                                    }                                });                                error = await new Promise(iResolve => {                                    conn.zadd(args.params, zSetList, function (err, _) {                                        iResolve(err)                                    });                                });                            }                            break;                        default:                            error = "错误的操作"                    }                }                break;            case 5:                // 删除                switch (args.type) {                    case 1:                        // key类型操作                        error = await new Promise(inResolve => {                            conn.del(args.name, function (err, _) {                                inResolve(err)                            })                        });                        break;                    case 2:                        // name类型操作                        switch (args.r_type) {                            case 2:                                error = await new Promise(inResolve => {                                    conn.hdel(args.name, `${args.params}`, function (err, _) {                                        inResolve(err)                                    })                                });                                break;                            case 3:                                error = await new Promise(inResolve => {                                    conn.lrem(args.name, 1, `${args.params}`, function (err, _) {                                        inResolve(err)                                    })                                });                                break;                            case 4:                                error = await new Promise(inResolve => {                                    conn.srem(args.name, `${args.params}`, function (err, _) {                                        inResolve(err)                                    })                                });                                break;                            case 5:                                error = await new Promise(inResolve => {                                    conn.zrem(args.name, `${args.params}`, function (err, _) {                                        inResolve(err)                                    })                                });                                break;                            default:                                error = "错误的操作";                                break;                        }                        break;                    default:                        error = "错误的操作";                        break;                }                break;            case 6:                // 值变更                switch (args.r_type) {                    case 1:                        error = await new Promise(inResolve => {                            conn.set(args.name, args.params, function (err, _) {                                inResolve(err)                            })                        });                        break;                    case 2:                        if (!args.key) {                            error = "缺少key"                        } else {                            error = await new Promise(inResolve => {                                conn.hset(args.name, args.key, args.params, function (err, _) {                                    inResolve(err)                                })                            });                        }                        break;                    case 3:                        if (!(args.key >= 0)) {                            error = "缺少index"                        } else {                            error = await new Promise(inResolve => {                                conn.lset(args.name, args.key, args.params, function (err, _) {                                    inResolve(err)                                })                            });                        }                        break;                    case 4:                        // set 处理                        error = await new Promise(inResolve => {                            conn.sadd(args.name, args.params, function (err, _) {                                inResolve(err)                            })                        });                        if (!error) {                            error = await new Promise(inResolve => {                                conn.srem(args.name, args.key, function (err, _) {                                    inResolve(err)                                })                            });                        }                        break;                    case 5:                        // z-set处理                        error = await new Promise(inResolve => {                            conn.zadd(args.name, [args.score, args.params], function (err, _) {                                inResolve(err)                            })                        });                        if (!error) {                            error = await new Promise(inResolve => {                                conn.zrem(args.name, args.key, function (err, _) {                                    inResolve(err)                                })                            });                        }                        break;                    default:                        error = "错误的操作";                        break;                }                break;            case 7:                // z-set设置score                if (args.r_type !== 5) {                    error = "错误的操作"                } else {                    // zadd向有序集合添加一个或多个成员，或者更新已存在成员的分数                    conn.zadd(args.name, [parseInt(args.params), `${args.key}`], function (err, _) {                        error = err                    });                }                break;            default:                error = "错误的操作"        }        if (error) {            reject(error.toString())        } else {            resolve(true)        }    })}function RedisNameValue(conn, args) {    // 获取redis对应name的数据    return new Promise(async (outResolve, outReject) => {        let resp = {result: "", error: ""};        switch (args.r_type) {            case 1:                resp = await new Promise(resolve => {                    conn.get(args.name, async function (err, res) {                        resolve({result: res, error: err})                    });                });                break;            case 2:                resp = await new Promise(resolve => {                    conn.hkeys(args.name, function (err, res) {                        let retList = [];                        res.forEach(item => {                            retList.push({"name": args.name, "key": item, "r_type": 2})                        });                        resolve({result: retList, error: ""})                    })                });                break;            case 3:                resp = await new Promise(iResolve => {                    conn.llen(args.name, function (err, len) {                        iResolve({result: len, error: err})                    })                });                if (!resp.error) {                    resp = await new Promise(resolve => {                        conn.lrange(args.name, 0, resp.result, function (err, res) {                            let retList = [];                            res.forEach((item, index) => {                                retList.push({"name": args.name, "index": index, "item": item, "r_type": 3})                            });                            resolve({result: retList, error: ""})                        });                    });                }                break;            case 4:                resp = await new Promise(resolve => {                    conn.smembers(args.name, function (err, res) {                        let retList = [];                        res.forEach(item => {                            retList.push({"name": args.name, "member": item, "r_type": 4})                        });                        resolve({result: retList, error: ""})                    });                });                break;            case 5:                resp = await new Promise(resolve => {                    let resLen = 0;                    let retList = [];                    let nextIndex = 0;                    conn.zscan(args.name, 0, function (err, res) {                        let resList = res[1];                        resLen = resList.length;                        resList.forEach((item, index) => {                            if (nextIndex <= index) {                                retList.push({                                    "name": args.name,                                    "score": resList[index + 1],                                    "member": item,                                    "r_type": 5                                });                                nextIndex += 2                            }                        });                        if (retList.length === resLen / 2) {                            resolve({result: retList, error: ""})                        }                    });                });                break;            default:                resp.error = "错误的类型";                break;        }        if (resp.error) {            outReject(resp.error.toString())        } else {            outResolve(resp.result)        }    });}function RedisKeyValue(conn, args) {    // 获取redis对应的key_filed数据    return new Promise(async (outResolve, outReject) => {        let resp = {result: "", error: ""};        switch (args.r_type) {            case 2:                resp = await new Promise(resolve => {                    conn.hget(args.name, args.key, function (err, res) {                        resolve({result: res, error: err})                    });                });                break;            case 3:                resp = await new Promise(resolve => {                    conn.lindex(args.name, parseInt(args.key), function (err, res) {                        resolve({result: res, error: err})                    });                });                break;            default:                resp.error = "错误的操作"        }        if (resp.error) {            outReject(resp.error.toString())        } else {            outResolve(resp.result)        }    })}function RedisCommand(conn, command) {    // redis远程命名操作    let execArgs = [];    let commandList = command.split(" ");    let execCommand = commandList[0].trim();    commandList.forEach((item, index) => {        if (index > 0) {            execArgs.push(item.toString().trim())        }    });    return new Promise(async (outResolve, outReject) => {        let resp = await new Promise(resolve => {            conn.send_command(execCommand, execArgs, async function (err, res) {                let resError = "";                if (err) {                    resError = await new Promise(inResolve => {                        let errorList = err.toString().split(":");                        let retError = "";                        errorList.forEach((item, index) => {                            if (index > 0) {                                retError += item                            }                        });                        inResolve(retError)                    });                }                let retRes = res ? res : 'null';                resolve({result: retRes, error: resError})            })        });        if (resp.error) {            outReject(resp.error)        } else {            outResolve(resp.result)        }    })}export default {    "RedisPing": RedisPing,    "RedisEdit": RedisEdit,    "RedisInfo": RedisInfo,    "RedisName": RedisName,    "RedisNameValue": RedisNameValue,    "RedisKey": RedisKey,    "RedisKeyValue": RedisKeyValue,    "RedisCommand": RedisCommand}